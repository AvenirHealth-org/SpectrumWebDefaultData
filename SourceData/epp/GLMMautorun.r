#
#  GLMMautorun.R
#
# The following R code runs GLMM on each of the surveillance data files generated by EPP in the 
# directory %APPDATA%/EWC/GLMM.It generates a file with the suffix _imputed_GLMM.csv which EPP
# can then read to generate the pseudo-sites from the hierarchical model to inform the fitting in
# areas with more limited data. Once it has run these surveillance data files, it deletes them for
# good housekeeping purposes
#
# The packages "sp" and "INLA" are required, the following code will install them automatically
# if necessary before starting.Please be sure you have an active Internet connection.
#
is.installed <- function(mypkg){
  is.element(mypkg, installed.packages()[,1])
} 

if(!is.installed("sp")){
  install.packages("sp")
} else {
  print ("Package sp is already installed")
}

if(!is.installed("INLA")){
  install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
} else {
  print ("Package INLA is already installed")
}

# load libraries
library(INLA);  library(splines)

runDir <- paste (Sys.getenv("APPDATA"), "/EWC/GLMM", sep="")
if(!file.exists(runDir)){
  print ("Directory %APPDATA%/EWC/GLMM does not exist, please run EPP first")
} else {
  print (paste("Running files found in the directory: ",runDir))
  setwd(runDir)
  files <- list.files(pattern = "_surv_GLMM\\.csv$")
  if(length(files) == 0){
    print ("NO FILES FOUND: have you run EPP and created the necessary surveillance data file?")
  }
  for(runFile in files){
    print(paste("Running GLMM on the file:", runFile))
    #TFB beginning of Le's code
    country = strsplit(runFile, "_")[[1]][1]
    country = strsplit(country, " ")[[1]][1]
    # load data 
    Data = read.csv(runFile, header=TRUE, fill=TRUE, colClasses="character", skip=1)  #TFB change name of file here
    # the first col is area name, the second col is state name, the following cols are Years starting from 1985
    data.header = colnames(Data) 
    Area = Data[,1]
    Site = Data[,2]
    data.original <- as.matrix((apply(Data[,-c(1,2)],2,as.numeric)))
    data.original[which(data.original==-1)] = NA
    data.Year <- as.numeric(substring(colnames(data.original), 2))   # should be 1985:2020
    
    data.prev = data.original[seq(1,nrow(data.original),2), ]
    data.area = Data[seq(1,nrow(data.original),2),1] 
    
    # create data frame to use
    createDF <- function(inData, inArea, inSite, inDataYear) {
      HIV.p = HIV.n = Year = Site = Area = NULL
      for (i in 1:(nrow(inData)/2)){
        HIV.i = round(inData[2*i-1,]/100 * inData[2*i,])
        HIV.p = c(HIV.p, as.numeric(HIV.i))                   # postive cases at site i
        HIV.n = c(HIV.n, as.numeric(inData[2*i,] - HIV.i))    # negative cases at site i
        Year = c(Year, inDataYear) 
        Site = c(Site, rep(inSite[2*i-1], length(inDataYear)))
        Area = c(Area, rep(inArea[2*i-1], length(inDataYear)))
      }
      Site = as.factor(Site);    Area = as.factor(Area); 
      outData=data.frame(Site,Area,Year,HIV.p,HIV.n) 
      return(outData)
    }
    iData = createDF(data.original, Area, Site, data.Year)
    nsite = length(unique(iData$Site))
    nyear = length(unique(iData$Year))
    narea = length(unique(iData$Area))
    iData$site = rep(1:nsite,each=nyear)
    iData$size = iData$HIV.p+iData$HIV.n
    iData$prev = iData$HIV.p/iData$size
    str(iData);  iData[1:10,]   # look at dataset
    
    # define imputed sub-epidemic
    nimpute = nyear*narea
    data_impute = data.frame(matrix(ncol=ncol(iData),nrow=nimpute))
    names(data_impute) = names(iData)
    data_impute$site = 0
    data_impute$Area = rep(unique(iData$Area),each=nyear)
    data_impute$Year = rep(unique(iData$Year),narea)
    data = rbind(iData, data_impute)
    
    ##############################################################################
    ## II. Fit INLA and estimate area level trend
    ##############################################################################
    n = dim(data)[1]; nsb = ns(data$Year,df=4)
    X1=nsb[,1]; X2=nsb[,2]; X3=nsb[,3]; X4=nsb[,4]
    data$area4=data$area1=data$area2=data$area3=data$area=as.numeric(data$Area)
    
    forms = list(NA, NA, NA);
    forms[[1]]=HIV.p~ns(Year, df=4)+f(Area,model="iid")+f(Site,model="iid");
    forms[[2]]=HIV.p~ns(Year,df=4)+f(area1,X1,model="iid")+f(area2,X2,model="iid")+
      f(area3,X3,model="iid")+f(area4,X4,model="iid")+f(Area,model="iid")+f(Site,model="iid");
    forms[[3]]=HIV.p~Area*ns(Year,df=4)+f(Site,model="iid");
    
    set.seed(2016)              # set seed
    ptm <- proc.time()
    fit_inla = inla(forms[[2]], family="binomial", Ntrials=size, data=data,
                    control.predictor = list(link = 1),control.compute = list(dic=TRUE, waic=TRUE))
    time.used = proc.time() - ptm
    print(paste("Time used =", round(time.used[3]), "secs"))
    # summary(fit_inla)
    
    
    # subset to Years that have data
    data.Range = which(apply(data.original, 2, sum, na.rm=T)>0)
    data.Range = data.Year[1] + data.Range - 1
    data.Range = min(data.Range):max(data.Range)
    
    
    # get posterior mean and std of area-level fit
    ly = fit_inla$summary.fitted.values
    y.fit = cbind(data[(nrow(iData)+1):n,1:3], ly[(nrow(iData)+1):n,c(1,2,3,4,5)])
    # rho = fit_inla$summary.hyperpar$mean[1]
    
    y.impute = NULL
    Area.name = unique(iData$Area)
    for (i in 1:length(Area.name)) {
      region = Area.name[i]
      
      #jpeg(file=file.path("Graphs", paste(country, "_", region, "_prev", ".png", sep="")), height=360, width=560) #TFB edit
      #plot(data.original[1,]~seq(1985,2020), xlab = "Year", ylab = "Prevalence(%)", main=paste("Prevalence of HIV in", region, country), 
      #     lty=2, cex.axis=0.8, cex.lab=0.8, cex.main=0.9, lwd=2,
      #     xlim = c(1985, 2020), ylim = c(0,1.2*max(data.prev[data.area==region,], na.rm=T)), type = "n")
      #for (site in which(data.area==region))
      #  points(data.prev[site,]~seq(1985,2020), col = site, lwd = 2, pch = 1, cex=0.5)
      
      subArea <- which(y.fit$Area==region)
      y.mean = y.fit$mean[subArea[1:length(data.Year)]]*100
      y.interval = y.fit[subArea[1:length(data.Year)], c(6,8)]*100
      y.sd = y.fit$sd[subArea[1:length(data.Year)]]*100
      # p.var = y.sd^2/100^2 *(1-rho[1]) + y.mean/100*(1-y.mean/100)*rho[1]
      # y.impute = rbind(y.impute, y.mean*1, y.mean*(100-y.mean)/p.var/100^2)
      y.impute = rbind(y.impute, y.mean*1, y.mean*(100-y.mean)/y.sd^2)
      
      #lines(y.mean[data.Range+1-data.Year[1]]~data.Range, lwd=4, col="black")
      #lines(y.interval[data.Range+1-data.Year[1],1]~data.Range, lwd=2, lty=2, col="black")
      #lines(y.interval[data.Range+1-data.Year[1],2]~data.Range, lwd=2, lty=2, col="black")
      #dev.off()
    }
    
    y.impute = data.frame(y.impute)
    y.impute[,-(data.Range+1-data.Year[1])] = -1
    y.impute = cbind(rep(Area.name,each=2), rep("female general pop", nrow(y.impute)), y.impute)
    colnames(y.impute) = c("Area", "sub-Pop", data.Year)  
    
    #TFB this is the end of Le's code
    
    saveFileName <- gsub("_surv_GLMM", "_imputed_GLMM", runFile)  #Next lines save to a different filename than original
    print(paste("Saving to file:", saveFileName))
    
    write.csv(y.impute, file=saveFileName, row.names=FALSE, na="")
    print (paste("Successfully run, removing file", runFile))
    file.remove(runFile)
  }
}


